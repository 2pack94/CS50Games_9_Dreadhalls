Game Description:
In this 3D First-Person game the player spawns in an at runtime autogenerated maze. The objective is to traverse the maze
and find a pickup that brings the character to the next maze.
There is also a monster that patrols around the maze using the NavMesh Navigation System.
The monster can detect the player, chase and attack.
This game uses a package from the Unity asset store that implements a simple FPS character controller.
The FirstPersonController Component is based on the Unity CharacterController Component and on Cinemachine Cameras.
A more advanced implementation of a FPS character controller with more features
(based on a CharacterController Component and on normal Cameras) can be found in the scripts of the Unity FPS-Microgame:
https://assetstore.unity.com/packages/templates/fps-microgame-156015

Dependencies:
Starter Assets - First Person Character Controller (Version 1.1.1) by Unity Technologies:
https://assetstore.unity.com/packages/essentials/starter-assets-first-person-character-controller-196525
LowPoly Dungeon Modules (Version 1.0) by Magicpot Inc.: https://assetstore.unity.com/packages/3d/environments/dungeons/lowpoly-dungeon-modules-108997
Monster Orc (Version 1.0) by VK GameDev: https://assetstore.unity.com/packages/3d/characters/humanoids/monster-orc-146616
Experimental Unity Packages:
Can be added to the Project via the Package Manager:
"Plus Button" -> "Add package by name" -> Enter package name (e.g. com.unity.example)
AI Navigation (Version 1.0.0-exp.4): com.unity.ai.navigation

Lighting Settings for this Game:
Open Lighting Settings: Window -> Rendering -> Lighting -> Environment
Environment Lighting Source: Color
    Use a flat color for all ambient light.
Fog: Fog is the effect of overlaying a color onto objects dependant on the distance from the camera.

Camera Settings for this Game:
Select Camera Component -> Clear Flags: Solid Color
The screen is cleared to a flat color instead of a skybox before rendering.

Cinemachine Cameras: https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/CinemachineOverview.html

Unity CharacterController: https://docs.unity3d.com/Manual/class-CharacterController.html

Navigation with NavMesh: https://docs.unity3d.com/Manual/nav-NavigationSystem.html
Open the Navigation window: Window -> AI -> Navigation
1. Select Geometry in the Scene (Mesh Renderers and Terrains)
2. Navigation Window -> Object: Mark the selected objects as "Navigation Static" to be processed by the NavMesh.
Set the Navigation Area Type (Walkable, Not Walkable, ...)
3. Navigation Window -> Bake: Specify Agent parameters and Bake the NavMesh
Note: This can only be used for 1 agent type and for level sections that exist in the scene before running the game.
4. Add a NavMeshAgent Component to a GameObject and assign an Agent Type that was created under: Navigation Window -> Agents.

NavMesh building components (experimental): https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.0/manual/index.html
Offer additional controls for generating and using NavMeshes at run time and in the Editor.
Add a GameObject with a NavMeshSurface Component to the scene.
Each NavMeshSurface Component represents the walkable area for a specific NavMeshAgent.
The Area Type of a GameObject is specified by adding a NavMeshModifier Component and selecting the Override Area checkbox.
To correctly build the NavMesh for narrow passages the voxel size should be reduced.
The BuildNavMesh() method of the NavMeshSurface Component can be used to build the NavMesh at runtime.

Graphics Performance optimization: https://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html
GPU instancing: https://docs.unity3d.com/Manual/GPUInstancing.html
    Render multiple copies of the same mesh in a single draw call.
    To use GPU instancing for a material, select the "Enable GPU Instancing" option in the Inspector.
Draw call batching: https://docs.unity3d.com/Manual/DrawCallBatching.html
    Combines meshes so that Unity can render them in fewer draw calls.
    static batching: combines meshes that don't move to reduce draw calls. Applies to GameObjects marked as batching static.
    dynamic batching: batches moving GameObjects to reduce draw calls.
Unity will apply only 1 of the 3 optimizations in this order: static batching, GPU instancing, dynamic batching

Occlusion culling: https://docs.unity3d.com/Manual/OcclusionCulling.html
Prevents Unity from performing rendering calculations for GameObjects that are completely occluded by other GameObjects.
Applies to GameObjects marked as "Occluder Static" or "Occludee Static".
Occlusion culling data for a scene must be baked inside of the Unity Editor.
It will then load the baked data into memory at runtime.
Next to occlusion culling, frustum culling is always used. It excludes GameObjects from rendering that do not fall within
the Cameraâ€™s view frustum: https://docs.unity3d.com/Manual/UnderstandingFrustum.html
